# Effective C++

## 1.了解C++默默编写并调⽤哪些函数

一个空类，编译器会自动声明：

​	1.默认构造函数

​	2.拷贝构造函数

​	3.拷贝赋值函数

​	4.移动构造函数（参数中使用std::move将其转化为右值）

​	5.析构函数

PS.当一个class内含有reference/const成员时，编译器不提供默认拷贝赋值运算符（不重载“=”），只能由程序员⾃⼰编写，这是因为C++不允许改变reference成员的指向，也不允许更改const成员。



## 2.为多态基类声明虚析构函数

当⼀个基类指针指向⼀个⼦类对象时，若基类的析构函数不是virtual函数，那么在delete基类指针的时候，只会释放基类对象的资源，不会释放⼦类对象的资源，从⽽造成内存泄漏

虚函数的实现原理

​	1.每个含有virtual函数的class都有⼀个vtbl（虚函数表），vtbl中存储的是指向各个虚函数的函数指针

​	2.每个对象内存空间内存在⼀个vptr（虚指针），这个vptr指向类的vtbl

​	3.当对象调⽤某个virtual函数的时候，编译器根据对象的vptr找到类的vtbl，在vtbl中寻找适当的函数指针

注意：

​	1.不作为基类使⽤的class不要声明析构函数为virtual函数，因为虚表和虚表指针会占⽤额外的内存

​	2.std::string和STL容器的析构函数都是non-virtual，不要作为基类使⽤



## 3.不要让异常逃离析构函数

C++并不禁⽌析构函数抛出异常，但是不建议这样做

有两个异常存在的情况下，程序不是结束执⾏会导致不明确的⾏为



## 4.不要在派生类的构造函数和析构函数中调用虚函数

⽗类的构造函数的执⾏早于⼦类的构造函数，当⽗类的构造函数执⾏时，⼦类的成员变量尚未初始化，如果此时调⽤的虚函数下降⾄⼦类层次，会存在使⽤⼦类未初始化成员的风险，因此C++禁⽌这种危险

⼦类对象在调⽤⽗类构造函数期间，对象类型是基类⽽不是⼦类，不仅虚函数会使⽤⽗类版本，此时使⽤ dynamic_cast和typeid，也会把对象视为基类类型

对于析构函数也是同理

Java，C# 允许在派生类的构造函数和析构函数中调用虚函数，但是此时调用的也是基类的版本，因为派生类还没有完全构造



## 5.operator=的多用途

1.operator=返回一个绑定到*this的引用可以实现连锁赋值

```c++
A operator = (const A& other){
    ...
    return *this; // 将右边的对象赋给左边的对象
}
A a,b,c;
a = b = c; // 连续赋值的顺序是从右往左，即先b=c，然后a=b
```

2.operator=实现自我赋值

等号右边的东西和等号左边的东西是同⼀份（地址相同）



## 6.赋值对象时不要忘记每一个成分

复制函数包括，拷贝构造函数，拷贝赋值函数

这两个函数之间是完全独立的，不存在相互调用关系，因为前者用来初始化，后者只能用于已初始化的对象身上

要想消除复制函数的重复代码，可以建⽴⼀个新的成员函数给复制函数调⽤，这个函数通常是private且命名为init



## 7.使用成对的new delete

new/new[]创建，delete/[]delete删除



## 8.了解inline

内联函数将对函数的每一个调用都用函数本体替代，调用不承受额外开销，编译器对其执行语境相关最优化

增加⽬标码⼤⼩，额外的换页⾏为，降低缓存击中率，效率损失

对虚函数进⾏inline⽆意义，虚函数是运⾏时确定，inline是在编译期替换

编译器⼀般不对“通过函数指针进⾏调⽤”提供inline，是否inline取决于调⽤的⽅式



## 9.区分接口继承和实现继承

public继承由函数接口继承+函数实现继承组成

纯虚函数的两个特性：

​	1.它们必须被任何继承了它们的具象class重新声明

​	2.在抽象class中通常没有定义

声明⼀个纯虚函数的⽬的是为了让派⽣类只继承函数接口和缺省实现，派生类根据自身需求进行实现

任何派⽣类都不应该尝试修改非虚函数，non-virtual函数代表不变性>特异性，不应该在派⽣类被重新定义。重新定义则可能出现⽭盾，这样就不⼀定适⽤于基类，那么就不应该public。















