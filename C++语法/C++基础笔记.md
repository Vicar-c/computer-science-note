# C++基础

## C++三大特性：继承，封装与多态

访问权限：public，protected，private

在定义类的代码内部，无论什么访问权限，都是可以相互访问的。

在类的外部，尤其是“派生类内部”和“派生类对象”的访问权限与公有继承，保护继承和私有继承息息相关。

​	1.公有继承：基类的公有，保护成员被继承，在派生类的访问权限保持为公有，保护。派生类对象可以直接访问这些公有成员。

​	2.保护继承：基类的公有，保护成员被继承，在派生类的访问权限都变为保护。因此派生类对象无法直接访问基类公有成员（变成保护的了）。

​	3.私有继承：基类的公有，保护成员被继承，在派生类的访问权限都变为私有。同理派生类对象无法直接访问基类公有成员（变成私有的了）。

保护继承相对于私有继承的最大优势是继续的派生，对于派生类的派生类而言，显然保护继承起码保证类内部能够访问，同时也能使外部对象无法直接访问。

注意，无法直接访问，但可以通过基类/派生类提供的公共接口进行访问。

如果希望一个类能直接访问另一个类的私有成员，使用友元。

### 1.继承

继承的三种方式：

​	1.实现继承：使用基类的属性和方法。

​	2.接口继承：仅使用属性和方法的名称，子类需要提供实现。

​	3.可视继承：也可以等同于实现继承，更倾向于图形界面编程中，子控件使用基控件的布局，外观和实现代码。

C++支持单继承，多继承和虚继承。

#### 继承的类布局

派生类对象中包含基类的所有数据成员，C++将基类对象直接放在派生类对象的内部，去掉了间接访问的开销。

C++ 保证出现在派生类中的基类子对象保持其原样，即基类子对象的内存布局和一个独立的基类对象是相同的（包括为了对齐而插入的填充）。

基类和派生类数据的布局没有先后的强制规定，但一般都会把基类放到前面。同时，具体继承（与虚继承相对）不会引入时间和空间上的开销。

多继承中，如果将派生类指针转换为基类指针，需要编译器针对转换的具体基类进行一些处理：

​	1.将派生类指针赋给它第一基类的指针，只需要赋值即可，因为它们的地址相同。（这也被称为对象切片）。

​	2.如果想要赋值给第二和后续基类的指针，就需要修改地址，加上（或减去）中间的基类子对象大小。

#### 虚继承的影响

默认情况下，派生类中含有继承链上每个类对应的子部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。

虚继承主要用来解决钻石继承（或菱形继承）带来的问题，比如标准库中的IO类：

<img src="C:\Users\Vica\AppData\Roaming\Typora\typora-user-images\image-20231207151439606.png" alt="image-20231207151439606" style="zoom:100%;" />

读写函数（istream/ostream）显然需要在一个base_ios中进行管理，不能包含两份base_ios子对象（注意这里的base_ios是基类，我们实现的是iostream），否则会出现引用不清晰问题（一个实现类下包含两个同名的基类）

虚继承使得某个类做出声明，承诺愿意共享它的基类。不管虚基类在继承体系中出现了多少次，在派生类中都只包含一个共享的虚基类对象。（子类中只有一份间接父类的数据，对上图来说就是iostream）

```C++
class base_ios{
    ...
};
class istream: public virtual base_ios{
    ...
};
class ostream: public virtual base_ios{
    ...
};
class iostream: public istream, public ostream{
    ...
};
```

在虚继承中，父类数据不会存放在虚继承的子类中，子类会通过一个虚基表指针vbptr，指向虚基表，虚基表中存在偏移量，这个量就是表的地址到父类数据地址的距离。

### 2.封装

数据与代码捆绑，避免外界的访问。

访问修饰符的检查在编译器完成而不是运行时，直接限制了外部代码对内部数据的访问。

### 3.多态

多态指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。

C++支持两种多态形式：动态多态（运行时多态，根据绑定到指针或引用上的动态类型来决定调用调用虚函数的哪个版本）和静态多态（编译期多态，包括模版的参数化，重载）

动态多态允许将子类类型的指针赋值给父类类型的指针，即使用基类类型的指针来引用派生类的对象，在运行时，程序会根据实际对象的类型调用正确的成员函数。

被派生类地址赋值的基类指针，在调用基类方法时会直接调用派生类的同名方法而不是基类下的方法。

要实现动态多态性，基类下调用的方法要和派生类对应的方法满足三个一致性：

​	1.函数名称相同。

​	2.参数列表相同，包括参数类型和顺序。

​	3.返回类型相同。

实现多态的两种方式：

​	1.覆盖（override）：子类重写父类虚函数（动态多态绑定，运行时确定而不是编译时确定）

​	2.重载（overload）：多个同名函数，参数列表不同（这不是上面讲的动态绑定多态，而是静态绑定多态，静态绑定代表编译时编译器会直接选择调用哪一个函数）

#### 虚函数表

C++通过虚函数表（vtable）支持虚函数机制，每个含有虚函数的类都会有一个虚函数表，里面记录虚函数实例的地址，包括：

​	1.这个类定义的虚函数实例（包括override基类的函数实例）

​	2.继承自基类的虚函数实例

​	3.类自己定义的纯虚函数（纯虚函数的继承一定会被override）的表项指向一个默认处理函数pure_virtual_called()，如果错误调用程序就会直接结束

![image-20231207161444292](C:\Users\Vica\AppData\Roaming\Typora\typora-user-images\image-20231207161444292.png)

每个虚函数同时会被分配一个索引值，通过该索引值查找虚函数表以实现动态绑定。同时，虚表一般都是在对象内存布局中的起始位置

类的实例对象在实例化时会包含虚函数表指针（vptr），指向该类型的虚函数表。此外，RTTI （运行时类型识别）相关的信息往往也是通过 vptr 获得的。

不考虑虚继承的情况下，C++ 中对象的构造顺序是先按派生列表中的顺序构造基类、再构造派生类；析构时的顺序与构造相反。虚继承的中间顺序可能会出现一些区别，由最终派生类的继承顺序决定。

动态绑定实现的关键在于vptr的确定（指具体指向哪一个虚函数表）是在所有构造函数实现完之后根据当前的对象类型决定的。因此，在基类的构造函数中，vptr 指向的是 Base 的虚函数表；在派生类的构造函数中，vptr 指向的是派生类的虚函数表。同样地，在析构对象时，也会对 vptr 做相应的调整（即始终指向正确的虚函数表）。



## 数据类型

整型：short，int，long和long long

short至少16位，int至少与short一样长（最小int16_t）

long至少32位，与int一样长；long long至少64位，与long一样长

1 byte（字节） = 8 bits（位）

 无符号整型不存储负数，能够增大变量存储的最大值，数据长度不变。



## 指针与引用

指针存放某个对象的地址，其本⾝就是变量（命了名的对象），本⾝就有地址，所以可以有指向指针的指针。

指针可变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

引⽤就是变量的别名，从⼀⽽终，不可变，必须初始化。

不存在指向空值的引⽤，但是存在指向空值的指针。



## 关键字

### 1.const

作用：修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。

分类：

​	1.常量指针（底层const）：定义了一个指针，这个指针指向只读对象，不能通过常量指针来改变对象的值。

```c++
int tmp = 10;
// 下面这两种都是常量指针
const int* a = &tmp;
int const *a = &tmp;

*a = 9; // 错误，不能通过常量指针改变对象的值
tmp = 9; // 正确
```

​	2.指针常量（顶层const）：指针只能在定义时初始化，其他时候不能改变。强调的是指针的不可改变性。

```c++
int tmp = 12;
int tmp1 = 10;
// 指针常量
int* const p = &tmp;

*p = 9 // 正确，可以更改指向对象的值
p = &tmp1; // 错误，不能改变指针指向的对象
```

### 2.define/typedef

define:

​	1.只是简单的字符串替换，没有类型检查

​	2.在编译的预处理阶段起作⽤

​	3.防⽌头⽂件重复引⽤

​	4.不分配内存

typedef：

​	1.有对应的数据类型，需要进行判断

​	2.在编译，运行时起作用

​	3.在静态存储区中分配空间，在程序运⾏过程中内存中只有⼀个拷贝

### 3.define/inline

define:定义预编译时处理的宏，只是简单的字符串替换，无类型检查

inline：

​	1.先将内联函数编译完成⽣成了函数体直接插⼊被调⽤的地⽅，减少了压栈，跳转和返回的操作。没有普通函数调⽤时的额外开销

​	2.内联函数是一种特殊的函数，会进行类型检查

​	3.内联函数本质是编译器的一种请求，编译器可以拒绝这种这种请求（编译器会根据自己的优化策略和上下文来自己决定，如果不会带来性能提升，编译器是不会执行内联的请求的）

C++对inline的编译限制：

​	1.不能存在任何形式的循环语句

​	2.不能存在过多的条件判断语句

​	3.函数体不能过于庞⼤

​	4.内联函数声明必须在调用语句之前

### 4.override/overload

override是重写（覆盖）了⼀个⽅法,⼀般是⽤于⼦类在继承⽗类时，重写⽗类⽅法。

规则：

​	1.重写⽅法的参数列表，返回值，所抛出的异常与被重写⽅法⼀致（函数签名相同）

​	2.被重写的⽅法不能为private

​	3.静态⽅法不能被重写为⾮静态的⽅法

​	4.重写⽅法的访问修饰符⼀定要⼤于被重写⽅法的访问修饰符（public>protected>default>private）

override是重载，这些⽅法的名称相同⽽参数形式不同。

规则：

​	1.不能对访问权限，返回类型以及抛出的异常进行重载

​	2.重载的函数签名必须与原函数不一致（名称一定要相同）

​	3.方法的异常类型和数目不会对重载造成影响

使⽤多态是为了避免在⽗类⾥⼤量重载引起代码臃肿且难于维护。

重写需要增加override修饰符。

### 5.new/malloc

1.new内存分配失败时，会抛出std::bad_alloc异常，不会返回NULL；而malloc分配内存失败时返回NULL

2.new操作符申请内存分配时无需显式指定内存块的大小，而malloc需要指定

3.operator new/ operator delete可以被重载，而malloc/free不能被重载

4.new/delete会调⽤对象的构造函数/析构函数以完成对象的构造/析构。⽽malloc则不会 

5.malloc与free是C++/C语⾔的标准库函数,new/delete是C++的运算符 

6.new操作符从⾃由存储区上为对象动态分配内存空间，⽽malloc函数从堆上动态分配内存

![image-20231208133520854](C:\Users\Vica\AppData\Roaming\Typora\typora-user-images\image-20231208133520854.png)

### 6.constexpr/const

const表示“只读“，而constexpr表示”常量“。

constexpr 只能定义编译期常量，⽽ const 可以定义编译期常量，也可以定义运⾏期常量。

constexpr修饰的函数或变量也默认标记为了const，反之则不成立。

在C++11中，constexpr指定的函数返回值和参数必须是“字面值”，同时有且只有一行代码，C++14则只需要保证返回值和参数是字面值即可。

constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “将当前代码看成编译时就能得出常量值的表达式去优化”，否则const修饰的内容必须等到运行时编译器进入函数才能计算。

同时，const是无法修饰构造函数的，而constexpr可以修饰字面常量类的构造函数。

constexpr的优势：

​	1.为⼀些不能修改数据提供保障，写成变量则就有被意外修改的风险

​	2.有些场景，编译器可以在编译期对constexpr的代码进⾏优化，提⾼效率

​	3.相⽐宏来说，没有额外的开销，但更安全可靠

### 7.static/const

<img src="C:\Users\Vica\AppData\Roaming\Typora\typora-user-images\image-20231208134831348.png" alt="image-20231208134831348" style="zoom:150%;" />

static实现多个对象之间的数据共享和隐藏，默认初始化为0。

### 8.volatile

与const对立，意为“多变的”，用该关键字声明的变量表示变量随时可能发生变化，因此与该变量有关的运算，不要进⾏编译优化。编译器会从内存中重新装载内容，⽽不是直接从寄存器拷贝内容。

它确保了操作不会因为编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问。

### 9.extern

外部变量声明，为在函数或文件外部定义的全局变量。

### 10.前置++与后置++

前置++返回引用，后置++返回的是对象。

后置++返回的是常量对象，这主要是避免连续的“++”，例如i++++。

显然，后置++需要创建临时对象，这会带来构造和析构的额外开销。

### 11.std::atomic

C++11提供了std::atomic来保证原子操作。很多简单的命令，例如a++等，本质上线程都不安全（编译器的汇编指令对应三条指令）。

std::atomic是一个模版，一般来说不允许使用拷贝构造函数，因此需要先构造，再赋值。

```c++
std::atomic<int> value;
value = 99;

// 下面这种在一些编译器（例如G++）中无法通过
std::atomic<int> value = 99;
```

#### std::atomic_flag

最简单的原子类型，标识一个布尔标志。这个类型的对象可以在两个状态间切换：设置和清除。

std::atomic_flag 类型的对象必须被ATOMIC_FLAG_INIT初始化。初始化标志位是“清除”状态。

```c++
std::atomic_flag = ATOMIC_FLAG_INIT;
```

它是唯一一个需要如此初始化类型的原子类型，也是唯一一个保证无锁的类型（原子类型一般通过锁来保证原子性）。

std::atomic_flag只能做三件事情：销毁，设定清除或设置状态。

销毁——clear()，默认内存顺序为memory_order_seq_cst。

设定清除或设置状态——test_and_set()，是一个“读-改-写”的操作，可以应用任何顺序，默认内存顺序为memory_order_seq_cst。

```
内存顺序主要有以下两种——
memory_order_acquire：确保在该操作之前的所有读操作都在该操作之前执行，不允许后续的加载操作超越当前操作。 
memory_order_seq_rel：除了确保读操作外，还确保写操作，具有更强的同步保证。
```

std::atomic_flag非常适合做自旋互斥锁，初始化标志是“清除”，标识处于解锁状态。当想要上锁时，只需调用test_and_set方法，当为false时代表未被占用，而为true时代表已上锁，因此在while上等待。解锁直接清除std::atomic_flag即可。

```C++
class spinlock_mutex
{
	std::atomic_flag flag;
public:
	spinlock_mutex():flag(ATOMIC_FLAG_INIT){ }
	void lock()
	{
		while(flag.test_and_set(std::memory_order_acquire));
	}
	void unlock()
	{
		flag.clear(std::memory_order_release); // 如果使用默认也可以直接写为flag.clear()
	}
};
```



## C++强制类型转换

包括四个关键字：static_cast，dynamic_cast，reinterpret_cast和const_cast

### 1.static_cast

​	没有运⾏时类型检查来保证转换的安全性。

​	进⾏上⾏转换（把派⽣类的指针或引⽤转换成基类表⽰）是安全的。

​	进⾏下⾏转换（把基类的指针或引⽤转换为派⽣类表⽰），由于没有动态类型检查，所以是不安全的。 

使用：

​	1.⽤于基本数据类型之间的转换，如把int转换成char。

​	2.把任何类型的表达式转换成void类型。

### 2.dynamic_cast

​	在进⾏下⾏转换时，dynamic_cast具有类型检查（信息在虚函数中）的功能，⽐static_cast更安全。

​	转换后必须是类的指针、引⽤或者void*，基类要有虚函数，可以交叉转换。

​	dynamic本⾝只能⽤于存在虚函数的⽗⼦关系的强制类型转换；对于指针，转换失败则返回nullptr，对于引⽤，转 换失败会抛出异常。

### 3.reinterpret_cast

​	强制转换，无限制，但平台移植性差。

### 4.const_cast

​	常量指针转换为⾮常量指针，并且仍然指向原来的对象。

​	常量引⽤被转换为⾮常量引⽤，并且仍然指向原来的对象。

​	去掉类型的const或volatile属性。



## 运算符重载

重载运算符函数，本质还是函数调用，所以重载后：

​	1.既可以使用运算符的⽅式进行调⽤：data1+data2

​	2.还可以是调用函数的方式：operator+(data1, data2)

在C++中，当重载一个二元运算符作为类的成员函数时，该成员函数的左侧运算对象（被调用对象）将成为函数的this指针。这就是说，最左侧的运算对象相当于固定了this。



## C++内存模型

### 1.字符串操作函数

#### 	strcpy：复制字符串

```c++
char *strcpy(char *dest, const char *src)
dest：指向用于赋值内容的目标数组
src：要复制的字符串
返回一个指向最终目标字符串dest的指针
当dest的长度小于src时，会出现缓冲溢出的情况
    
char* strcpy(char *dst,const char *src) {// [1]
 assert(dst != NULL && src != NULL); // [2]
 char *ret = dst; // [3]
 while ((*dst++=*src++)!='\0'); // [4]
 return ret;
}
```

#### 	strlen：计算字符串长度

```c++
int strlen(const char *str)
```

#### 	strcat：添加字符串到结尾处

```c++
char *strcat(char* dest, const char* src)
将src所指字符串添加到dest结尾处
```

#### 	strcmp：两个字符串的比较

```c++
int strcmp(const char* str1, const char* str2)
两个字符串自左向右逐个字符相比（按 ASCII 值大小相比较），直到出现不同的字符或遇 \0 为止
显然返回值等于0代表完全相等，正数/负数无法确定两个字符串具体的关系
```

### 2.内存泄漏

什么是内存泄漏？

​	程序未能释放掉不再使⽤的内存的情况。

内存泄漏的分类：

​	1.堆内存泄漏（Heap leak）

​		主要指的是malloc/new/realloc（用于数组扩容）等从堆中分配的内存没有free或delete掉。

​	2.系统资源泄漏（Resource leak）

​		系统分配的资源⽐如套接字、文件描述符、管道等没有使⽤相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运⾏不稳定。

​	3.基类的析构函数非虚

​		这种情况下，当基类指针指向子类对象时，如果基类的析构函数非虚，那么子类的析构函数将无法调用（基类的析构函数可以正常调用），造成内存泄漏。

​		一般来说，子类析构函数视为基类析构函数的重载而不是重写，不加override关键字。

​		基类的虚析构函数可以触发动态绑定以调用子类的析构函数。

如何防止内存泄漏？

​	将内存的分配封装在类中（RAII），构造函数分配内存，析构函数释放内存。

​	使用智能指针（维护一个引用计数，重载了“*”和“->”）。

如何监测内存使用情况：

​	在g++编译器编译时加上“-g”选项，用以生成可调式信息的二进制文件。

​	在结果输出时使用valgrind关键字，可以监测整体的内存使用情况：

```shell
#valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./filename
```



## C++模版全特化和偏特化

模板分为类模板与函数模板，特化分为特例化（全特化）和部分特例化（偏特化）。

SFINAE：替换失败不是错误。它使得模板可以更加灵活地应对不同的参数情况，通过选择不同的模板实例来处理。

在调用顺序上：全特化>偏特化>通用模版

对函数模版来说：

​	1.模板和特例化版本应该声明在同⼀头⽂件，所有同名模板的声明应放在前⾯，接着是特例化版本

​	2.⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化

```c++
template<typename T1, typename T2>
void fun(T1 a, T2 b)
{
cout<<"模板函数"<<endl;
}
// 特化版本上面的template<>关键字仍然应该保留
template<>
void fun<int , char >(int a, char b)
{
cout<<"全特化"<<endl;
}
```



## 测试题目

### 1.计算下面的sizeof的值（windows32位系统下）

```c++
char str[] = "hello";
char* p = str;
int n = 10;
// 请计算
sizeof(str) = ? // 6，数组所占内存的大小包括'\0'，该终止符只会在字符数组中出现
sizeof(p) = ? // 4，指针的内容是地址，32位系统的地址位数也为32位，即4字节
sizeof(n) = ? // 4
void Func(char str[100])
 {
 // 请计算
 sizeof(str) = ? // 4，str作为指针指向数组的最前面，表示首元素的地址
 }
void* p = malloc(100);
// 请计算
sizeof(p) = ? // 4，p指向malloc分配的内存的起始地址
```

### 2.分析下列Test函数的运行结果

```c++
void GetMemory1(char* p) // 应该传递引用，即char*& p
{
 p = (char*)malloc(100);
}
void Test1(void)
{
 char* str = NULL;
 GetMemory1(str); // 这里如果输入&str，可以将上面参数改为char** p，也可以实现传引用一样的效果
 strcpy(str, "hello world");
 printf(str);
}
```

Test 1——程序崩溃，因为GetMemory1并不能传递动态内存（参数为值传递而不是引用传递，不会更改实际的输入），Test 1函数中的 str⼀直都是NULL。strcpy函数导致程序崩溃。

```c++
char *GetMemory2(void)
{
 char p[] = "hello world";	// 局部变量p在函数结束时超出了它的生存周期
 return p;
}
void Test2(void)
{
 char *str = NULL;
 str = GetMemory2();
 printf(str);
}
```

Test 2——可能是乱码。 因为GetMemory2返回的是指向“栈内存”的指针，该指针的地址不是NULL，使其原现的内容已经被清除，新内容不可知。

​		 没有动态内存分配（即没有从堆上分配内存），该指针作为局部变量存在栈内存中，函数执行结束后栈的空间也会被释放。

```c++
void GetMemory3(char** p, int num)
{
 *p = (char*)malloc(num);
}
void Test3(void)
{
 char* str = NULL;
 GetMemory3(&str, 100);
 strcpy(str, "hello");
 printf(str)
}
```

Test 3——能够输出hello但申请的内存没有释放，导致内存泄漏。

```c++
void Test4(void)
{
 char *str = (char*)malloc(100);
 strcpy(str, "hello");
 free(str);
 if(str != NULL) {
 strcpy(str, "world");
 cout << str << endl;
 }
}
```

Test 4——篡改了动态内存区的内容。在free(str)后，str成为了野指针，if(str != NULL)语句不起作用。

### 3.进程地址空间的具体分布

![image-20231210130504038](C:\Users\Vica\AppData\Roaming\Typora\typora-user-images\image-20231210130504038.png)

命令行参数与环境变量——命令执行程序的时候给程序的参数

栈区——存储局部变量和函数参数值（从高地址向低地址增长）

文件映射区（共享区）——位于栈和堆之间，使进程能够读写对应区域的文件；同时还能实现共享内存与零拷贝操作

堆区——动态申请内存用（堆从低地址向高地址增长）

BSS段——存放程序中未初始化的全局变量和静态变量

数据段——存放过程中已初始化的全局变量和静态变量

注意，对于64位而言，内核空间和用户空间分别置于地址的两端，用户空间的大小一般为128TB

### 4.C与C++的内存分配方式

​	1.静态存储区域分配——内存在程序编译的时候就已经分配好，这块内存在程序的整个运⾏期间都存在，如全局变量，static变量。

​	2.栈上创建——函数内局部变量的存储单元都可以在栈上创建，函数执⾏结束时这些存储单元⾃动被释放。栈内存 分配运算内置于处理器的指令集中，效率很⾼，但是分配的内存容量有限。

​	3.堆上分配（动态内存分配）——⽤malloc或new申请任意多少的内存，需要负责⽤free或delete释放内存。动态内存的⽣存期⾃⼰决定。

### 5.new/delete和malloc/free的关系

​	1.new/delete的底层调用了malloc/free。

​	2.new/delete主要用于类对象的动态内存分配和释放，它们会调用对应类的构造/析构函数，再对堆内存进行释放。



## 计算机的乱序执行

### 1.正常执行的情况

​	1.对同一块内存进行访问，此时访问的顺序不会被编译器修改

​	2.新变量的定义值依赖之前定义的变量，此时两个变量定义的顺序不会被编译器修改

在多线程的情况下计算机会出现乱序执行

### 2.C++提供的六种内存模型

​	memory_order_relaxed：没有任何同步或顺序限制

​	memory_order_consume：编译器需要优先考虑加载数据的操作（C++14被废弃）

​	memory_order_acquire：同步的读取操作，确保当前操作和之前的操作按照严格的顺序执行

​	memory_order_release：同步的写入操作

​	memory_order_acq_rel：同步读写

​	memory_order_seq_cst：所有的原子操作按照一个全局的总序列一致性执行（类似于分布式中的线性一致性）



















