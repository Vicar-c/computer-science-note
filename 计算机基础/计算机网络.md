# 计算机网络

## osI七层网络模型

1.物理层：定义物理设备标准，传输比特流。

2.数据链路层：建⽴逻辑连接、进⾏硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧为单位进⾏传输，以及如何控制对物理介质的访问。将⽐特组合成字节进⽽组合成帧，⽤ MAC 地址访问介质。

3.网络层：进⾏逻辑地址寻址，在位于不同地理位置的⽹络中的两个主机系统之间提供连接和路径选择。

4.传输层：定义了⼀些传输数据的协议和端口号，将从上层接收的数据进⾏分段和传输，到达⽬的地址后再进⾏重组。常常把这⼀层数据叫做段。

5.会话层：通过传输层建⽴数据传输的通路。

6.表示层：数据的表⽰、安全、压缩。

7.应⽤层：⽹络服务与最终⽤户的⼀个接⼜。这⼀层为⽤户的应⽤程序提供⽹络服务。



## 浏览器输入网址后发生了什么

1.URI解析：包括解析协议（如HTTP或HTTPS）、主机名、端口号、路径等信息。如果输入的内容不是合法的 URL，浏览器可能会进行一些纠正，例如自动添加缺失的协议。

2.DNS解析：将主机名解析成对应的 IP 地址，以便建立连接。浏览器会向本地 DNS 缓存、操作系统的 DNS 缓存或者进行 DNS 查询，获取主机名对应的 IP 地址。

3.建立TCP连接（HTTP需要通过TCP进行连接）：浏览器使用获取到的 IP 地址和端口号，通过 TCP 协议与服务器建立连接。这是一个三次握手的过程，确保客户端和服务器之间建立可靠的连接。

4.发起HTTP请求： 浏览器通过已建立的 TCP 连接向服务器发送 HTTP 请求。请求包括请求方法（GET、POST等）、路径、HTTP 版本号等信息。如果是 HTTPS，还会进行 SSL/TLS 握手过程来建立安全连接。

5.服务器处理请求：服务器接收到请求后，根据请求的路径和其他信息，执行相应的处理。

6.服务器返回响应：生成一个 HTTP 响应，其中包括状态码、响应头和响应体。响应体包含了请求的实际内容，如 HTML、CSS、JavaScript 文件等。

7.浏览器解析渲染：浏览器接收到服务器的响应后，会开始解析内容。对于 HTML，浏览器会构建 DOM 树；对于 CSS，会构建样式规则；对于 JavaScript，会执行脚本。这些操作最终形成了用户在浏览器中看到的网页。

8.显式页面



## 三次握手与四次挥手

### 三次握手

![image-20231213200135928](image-20231213200135928.png)

第一个SYN报文：客户端随机初始化序列号放入TCP首部序列号段，SYN置1。然后把SYN报文发送给服务端，表示发起连接，之后客户端处于SYN_SENT状态。

第二个SYN+ACK报文：服务端生成自己的序列号放入序列号段，确认号为客户端序列号+1，把SYN和ACK置为1。然后进入SYN_RCVD状态。

第三个ACK报文：确认号为服务端序列号+1，这次报文可以携带客户到服务端的数据，之后客户端处于ESTABLISHED状态。服务端在收到客户端的应答报文后，也进入ESTABLISHED状态。

### 为什么需要三次握手

1.三次握手可以阻止重复历史连接的初始化（主因）

当旧的SYN报文先到达服务端时，服务端回复一个ACK和SYN报文。而客户端收到这个报文后，可以判断这是否是一个历史连接（确认号-1=旧的SYN报文的序列号，序列号过期或超时），那么客户端就会发送RST报文给服务端，表示终止这一次连接。

两次握手在收到服务端的响应后开始发⽣数据，不能判断当前连接是否是历史连接。

三次握⼿可以让客户端在第三次握手时判断是否是历史连接并中断连接。

2.三次握手才可以同步双方的初始序列号

TCP的通信双方都必须维护序列号，序列号是可靠传输的关键因素。

包括——接收端可以去除重复数据；接收端可以按照序列号顺序接收；标识发送的数据包，哪些已经被收到

两次握⼿只保证了⼀⽅的初始序列号能被对⽅成功接收，没办法保证双⽅的初始序列号都能被确认接收

3.避免资源浪费

两次握⼿会造成消息滞留情况下，服务器重复接受⽆⽤的连接请求 SYN 报⽂，⽽造成重复分配资源

只有两次握⼿时，如果客户端的SYN请求连接在⽹络中阻塞，客户端没有收到服务端的ACK报⽂，会重新发送 SYN

由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建⽴⼀个连接

### 四次挥手

![image-20231213201947385](image-20231213201947385.png)

客户端打算关闭连接，因此发送一个TCP首部FIN标志位置为1的报文给服务端

服务端收到后，向客户端发送ACK应答报文，确认号为第一次挥手的序列号+1

等待服务端处理完数据后，向客户端发送FIN报文，确认号仍然为第一次挥手的序列号+1

客户端收到FIN报文后回一个ACK应答报文

服务器收到ACK报文后，进入close状态，服务器完成连接关闭

客户端在经过2MSL后，自动进入close状态，客户端也完成连接的关闭

### 为什么需要四次挥手

关闭连接时，客户端发送FIN报文，表示其不再发送数据，但还能接受数据（TCP流是全双工的，在一个流内能同时写和读）

客户端收到FIN报⽂，先回⼀个ACK应答报⽂，服务端可能还要数据需要处理和发送，等到其不再发送数据时，才发送FIN报⽂给客户端表⽰同意关闭连接

Tips：

​	1.服务端通常需要等待完成数据的发送和处理，所以FIN和ACK的报文是分开发送的

​	2.第⼀次ACK应答报⽂可能会延迟发送，取决于延迟确认特性。(延迟确认是指接收方不立即对收到的数据包进行确认，而是等待一段时间，看是否有更多的数据包到达，然后一起进行确认。这样可以减少确认报文的数量，提高网络的利用率。)

​	3.实际上，在第二次FIN报文中也包含着ACK标志位，表示接收方对之前的数据进行了确认

### 为什么TIME_WAIT等待的时间是2MSL

MSL是报文最大生存时间，超过这个时间的报文将被丢弃

网络中可能存在发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后又会向对⽅发送响应， 所以⼀来⼀回需要等待 2 倍的时间

2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报⽂，那么 2MSL 时间将重新计时（第四次挥手没有接收到的时候）

### 为什么需要TIME_WAIT状态

主动发起关闭连接的一方才有TIME_WAIT状态

TIME_WAIT状态的原因主要有两点：

​	1.防止具有相同四元组的旧数据包被接收到（确保原来连接的数据包消失）

​	2.保证被动关闭连接的一方能被正确的关闭，即保证最后的ACK能让被动接收方接收，从而帮助其正常关闭（因为如果接收不到会在这段时间内重传一个FIN以获得客户端的确认），也就是全双工通信的可靠性

有相同端口的 TCP 连接被复⽤后，被延迟的相同四元组的数据包抵达了客户端，那么客户端是有可能接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。

最后的ACK如果丢失，客户端直接进⼊close，服务端⼀直在等待ACK状态。当客户端发起建⽴连接的SYN请求， 服务端会发送RST报⽂回应，连接建⽴会关闭。 

### TIME_WAIT过多的危害

过多的TIME_WAIT状态主要的危害有两种：

​	1.内存资源占用

​	2.端口资源占用，甚至可能导致无法创建新连接



## 重传机制（TCP传输层）

### 超时重传

设定一个计时器，当超过指定的时间后，没有收到对⽅的确认ACK应答报⽂，就会重发该数据

两种情况：数据包丢失，应答丢失

![image-20231214135402113](image-20231214135402113.png)

RTT：往返时延，即数据从发送端传到另一端后发送端收到确认消息的时间

![image-20231214135535149](image-20231214135535149.png)

RTO：超时重传时间

超时重传时间既不能太大也不能太小，太大会降低网络传输效率，太小会出现不必要的重传导致网络的负载加大

![image-20231214135651443](image-20231214135651443.png)

超时重传时间的值应该略大于报文往返RTT的值，且是动态变化的

估计RTT的方式通常有以下两种：

​	1.需要采样RTT的时间，进行加权平均，算出一个平滑RTT的值，同时这个值需要不断变化

​	2.还要采样RTT的波动范围，以避免RTT出现较大波动而不及时对估计进行调整

如果是超时重发的数据，再次超时又要重传的时候，TCP的策略是将超时时间隔加倍

### 快速重传

专门针对数据包丢失的情况。当收到三个相同的ACK报⽂时，会在定时器过期之前，重传丢失的报⽂段。

TCP的接收方存在”累计确认“的机制，表示已经成功接收的最后一个按序到达的数据包，如果某个数据包未按序到达，接收方会发送一个重复的确认，告诉发送方需要重传丢失的数据包。所以才会出现收到三个相同ACK报文的情况。注意，在发送重复确认的时候，其他数据还是正常发送和接收的，并不是阻塞的。

具体重传的时候，需要考虑是重传之前的一个，还是重传所有的问题。

SACK（选择性确认）：这种方式需要在TCP头部的“选项”字段里加一个SACK，它可以将缓存的地图发送给发送方（将当前接收到的部分告诉发送方），这样发送方就可以知道具体数据的收到情况，并只重传丢失的数据。

显然，ACK中发送的内容，是“希望下一次发的内容”，与“实际接收到的内容”，并不一定相等

![image-20231214141521612](image-20231214141521612.png)

D-SACK（复制-选择性确认）：使用SACK告诉发送方有哪些数据被重复接收，适用于“正常发送，应答报文丢失”的场景，它不属于重传，属于一种反馈机制。但它运用到了重传的技术。

D-SACK的优势：

​	1.可以让发送方知道是发出去的包丢了，还是回传的ACK报文丢失

​	2.让发送方知道是否在重复发送

![image-20231214141924483](image-20231214141924483.png)

### 网络延时

网络延时可能会触发上述的所有重传内容：超时重传，快速重传（SACK），以及反馈D-SACK

![image-20231214142523914](image-20231214142523914.png)

## 滑动窗口（TCP传输层）

![image-20231214143646127](image-20231214143646127.png)

滑动窗口的核心是进行流控制，也可以在一定程度上确认报文丢失。

TCP每发送⼀个数据，都需要⼀次应答，然后继续发送，这样为每个数据包都进⾏确认应答，缺点是：数据往返时 间越长，⽹络吞吐量越低。

引⼊窗口即使往返时间较长，也不会降低⽹络通信效率。可以指定窗口⼤⼩，窗口⼤⼩就是⽆需等待确认应答，继续发送数据的最⼤值。

窗口实现就是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

以上述图片为例，只要发送⽅收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。

TCP头部有⼀个字段叫window，窗口⼤⼩。这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。

通常窗口的⼤⼩是由接收⽅的窗口⼤⼩来决定的。

滑动窗口以字节作为处理单位而不是以TCP的数据段作为单位有利于更精细的流控制，同时适应应用层的需求。

### 发送方的滑动窗口

![image-20231214144309078](image-20231214144309078.png)

在数据进一步发送后，可用窗口的大小变为0，现在已经到了临界值，如果没收到ACK应答无法继续发送数据

![image-20231214144552872](image-20231214144552872.png)

对于收到ACK的部分，滑动窗口会对应向右移动，发送窗口位置改变，可用窗口增加

![image-20231214145059935](image-20231214145059935.png)

### 程序表示发送方窗口

![image-20231214154026189](image-20231214154026189.png)

SYN.WND：表示发送窗口的大小（大小由接收方指定）

SYN.UNA：指向#2的第一个字节的序列号（已发送但未收到确认）

SYN.NXT：指向#3的第一个字节的序列号（未发送但在窗口内）

#4的第一个字节的序列号只需要将SYN.WND+SYN.UNA即可

可用窗口大小=发送窗口（SND.WND）-已发送未确定的大小（SND.NXT - SND.UNA）

### 接收方滑动窗口

![image-20231214154525943](image-20231214154525943.png)

接收方滑动窗口主要包含接下来可以接收的数据部分，包含两个指针：

RCV.WND：表示接收窗口的大小

RCV.NXT：指向#3的第一个字节的序列号（期望从发送⽅发送来的下⼀个数据字节的序列号）



## 拥塞控制

拥塞控制通过拥塞窗口来防⽌过多的数据注⼊⽹络，使得⽹络中的路由器或者链路过载

拥塞窗口cwnd是发送⽅维护的⼀个状态变量，根据⽹络拥塞程度⽽变化

发送窗口的大小是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最⼩值

⽹络中没有出现拥塞，cwnd增⼤，出现拥塞，cwnd减⼩

只要发送⽅没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞

### 拥塞控制算法

#### 1.慢启动

当发送⽅每收到⼀个 ACK，拥塞窗口cwnd 的⼤⼩就会加 1（这里加的是1个MSS，即TCP最大报文段长度），所以发包的个数会呈指数型增长。1->2->4->8->2的平方

```
在 TCP 连接建立时，两端的通信实体会通过 TCP 选项字段中的 MSS 选项进行协商，以确定在这个连接上能够发送的最大报文段大小。MSS 是以字节为单位的值，通常是考虑了网络传输的最大单元（MTU）减去 TCP 头部和 IP 头部的长度。
MSS=MTU−TCP头部长度−IP头部长度
```

包含一个慢启动门限sshresh状态变量：

​	1.当cwnd<sshresh时，使用慢启动算法

​	2.当cwnd>=sshresh时，使用拥塞避免算法

#### 2.拥塞避免算法

⼀般来说 ssthresh 的初始⼤⼩是65535字节，会进行动态调整。超过后会进⼊拥塞避免算法。

它的规则是：每当收到⼀个 ACK 时，cwnd 增加1/k（每次增加1/k个MSS）

拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长（“加法增长”），还是增长阶段，但是增长速度缓慢了⼀些

⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进⾏重传

当触发重传机制后，也进入了拥塞发生算法

#### 3.快重传（门限都会被设置为当前拥塞窗口的一半）

发生超时重传的情况时：

​	1.ssthresh 设为 cwnd/2（注意是拥塞时的拥塞窗口的一半，而不是初始的慢启动门限的一半）

​	2.cwnd会被重置为1，突然回到慢启动会导致网络卡顿

![image-20231214190246869](image-20231214190246869.png)

发生快速重传的情况时：

TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，此时cwnd = cwnd/2 ，也就是设置为原来的⼀半，ssthresh = cwnd

进入快速恢复算法

#### 4.快恢复

1.拥塞窗口cwnd = ssthresh + 3 （维持一定的发送窗口大小，+3也是因为快速重传的时候会收到3个重复的ACK）

2.重传丢失的数据包

3.如果再收到重复的 ACK，那么 cwnd 增加 1

4.如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，再次进入拥塞避免状态



## TCP和UDP

### TCP和UDP的区别

连接：TCP是⾯向连接的，在传输前需要三次握⼿建⽴连接，UDP不需要连接，即刻传输数据

服务形式：TCP只能⼀对⼀，点对点服务，UDP⽀持⼀对⼀、⼀对多、多对多通信

可靠性：TCP保证数据可靠交付，拥有确认应答和重传机制，⽆重复、不丢失、按序到达；UDP尽可能交付，不保证可靠性

连接控制机制：TCP拥有流量控制、拥塞控制，保证传输安全性等，UDP在⽹络拥堵情况下不会降低发送速率

首部大小：TCP⾸部长度不适⽤选项字段是20字节，使⽤选项字段长度增加(总长度为20-60字节)，UDP⾸部固定8字节

传输方式：TCP基于字节流，没有边界，但是保证传输顺序和可靠性;UDP继承了IP层特性，基于数据包，有边界可能出现乱序和丢包

分片方式：TCP数据⼤于MSS时会在TCP层将数据进⾏分⽚传输，到达⽬的地后同样在传输层进⾏合并，如果有某个⽚丢失则 只需要重传丢失的分⽚即可;

​		 UDP数据⼤于MTU时会在IP层分⽚，同样也在⽬的IP层合并，如果某个IP分⽚丢失，则需要将所有分⽚都进⾏重 传，开销⼤

### TCP与UDP的头部格式

UDP：

![image-20231215134535821](image-20231215134535821.png)

包长度：UDP首部的长度和数据的长度之和

校验和：检验报文段是否出现差错

TCP：

![image-20231215134623399](image-20231215134623399.png)

源端口号和目的端口号：⽤于多路复⽤/分解来⾃或送到上层应⽤的数据。告诉主机报⽂段来⾃哪⾥，传给哪个上层协议或应⽤程序

序列号：该报⽂段⾸字节的字节流编号，⽤来解决⽹络包乱序问题

确认应答号：对发送来的 TCP 报⽂段的响应，值是收到 的 TCP 报⽂段的序号值加1，⽤来解决不丢包的问题。序列号和确认应答号都⽤于实现可靠数据传输

首部长度：标识 TCP 头部有多少字节，最长 60

窗口大小：接收窗⼜，告诉对⽅本端TCP缓冲区还有多少空间可以接收数据，⽤来做流量控制

标志字段：

​	ACK：确认，表⽰确认应答号值是否有效，置1表⽰包含⼀个对已成功接收报⽂段的确认

​	RST：重置，可以拒绝一个连接请求或数据段

​	SYN：同步，请求建立一个连接

​	FIN：结束，用于断开连接，表示发送方并没有数据要继续传输

​	URG：紧急指针是否有效，与后面的紧急指针一起使用

​	PSH：服务端应立即从TCP接收缓冲区将数据读走，即应立即传递给上层应用，而不需要等待更多数据，对于及时响应的场景很有用

​	除了这6个外，还有NS（随机和，防止TCP发送端的数据包标记被意外或恶意改动），CWR(拥塞窗口减少请求量的标志)，ECE（拥塞控制的标志位，表示两端之间的通信是否存在网络拥塞，如果出现了就会置1）

校验和：接收⽅使⽤检验和来检查该报⽂段(头部+数据)中是否出现差错（CRC算法），同 UDP

### TCP选项

TCP头部的最后⼀个选项字段（options）是可变长的可选信息。这部分最多包含40字节。

选项的第⼀个字段kind说明选项的类型，有的TCP选项没有后⾯两个字段，仅包含1字节的kind字段

第⼆个字段length（如果有的话）指定该选项的总长度。该长度包括kind字段和length字段占据的2字节（kind和length各占据1字节长度，然后length里的内容是选项的总长度）

第三个字段info（如果有的话）是选项的具体信息

![image-20231215141758663](image-20231215141758663.png)

kind=0，选项表结束（EOP）选项：⼀个报⽂段仅⽤⼀次。放在末尾⽤于填充，⽤途是说明：⾸部已经没有更多的消息，应⽤数据在下⼀个32位开始处。（注意，TCP报文是32位对齐的，也就是即便选项字段只使用了8位，数据也仍然在选项前最后一位的32位之后，填充了24位）

kind=1，空操作（NOP）选项：没有特殊含义，⼀般⽤于将TCP选项的总长度填充为4字节的整数倍。

kind=2，最⼤报⽂段长度（MSS）选项：TCP连接初始化时，通信双⽅使⽤该选项来协商最⼤报⽂段长度。TCP模块通常将MSS设置为（MTU-40）字节 （减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报⽂段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是⼀ 般情况），从⽽避免本机发⽣IP分⽚。

kind=3，窗口扩大因子选项：TCP连接初始化时，通信双⽅使⽤该选项来协商接收窗口的扩⼤因⼦。在TCP的头部中，接收窗口⼤⼩是⽤16位表示的，故最⼤为65535字节，但实际上TCP模块允许的接收窗口⼤⼩远不⽌这个数（为了提⾼TCP通信的吞吐量）。 窗口扩⼤因⼦解决了这个问题。假设 TCP 头部中的接收通告窗口⼤⼩是 N，窗口扩⼤因⼦（移位数）是 M，那么 TCP 报⽂段的实际接收通告窗口⼤⼩是 N*2M，或者说 N 左移 M 位。注意，M的取值范围是 0～14。

​	和 MSS 选项⼀样，窗口扩⼤因⼦选项只能出现在同步报⽂段中，否则将被忽略。但同步报⽂段本⾝不执⾏窗口扩⼤操作，即同步报⽂段头部的接收窗口⼤⼩就是该 TCP 报⽂段的实际接收窗口⼤⼩。当连接建⽴好之后，每个数据传输⽅向的窗口扩⼤因⼦就固定不变了。

kind=4，选择性确认（Selective Acknowledgment，SACK）选项：SACK 技术使 TCP 只重新发送丢失的 TCP 报⽂段，⽽不⽤发送所有未被确认的 TCP 报⽂段。选择性确认选项⽤在 连接初始化时，表⽰是否⽀持 SACK 技术。

kind=5，SACK实际⼯作的选项：该选项的参数告诉发送⽅本端已经收到并缓存的不连续的数据块，从⽽让发送端可以据此检查并重发丢失的数据块。接下来的每个数据块包含一个左边沿参数和右边沿参数，各4字节（因此一个数据块8字节），左边沿和右边沿表示的位置之间的部分就是缺失的内容。一个TCP首部最多包含4个这样的块，最终大小为34<40。

kind=8，时间戳选项：提供了较为准确的计算通信双⽅之间的回路时间（Round Trip Time，RTT）的⽅法，为TCP流量控制提供信息。

### SYN攻击

攻击者伪造不同IP地址的SYN报⽂请求连接，服务端收到连接请求后分配资源，回复ACK+SYN包，但是由于IP地 址是伪造的，⽆法收到回应，久⽽久之造成服务端半连接队列被占满，⽆法正常⼯作

避免方式：

​	1.修改半连接队列⼤⼩，使服务端能够容纳更多半连接。此外还可以修改服务端超时重传次数，使服务端尽早丢弃⽆⽤连接

​	2.当半连接队列满时，启动syn cookie,后续连接不进⼊半连接队列，⽽是计算⼀个cookie值，作为请求报⽂序列号发 送给客户端，如果服务端收到客户端确认报⽂，会检查ack包合法性，如果合法直接加⼊到accept队列

### TCP保活机制

在⼀个定义的时间段内TCP连接⽆任何活动时，会启动TCP保活机制，每隔⼀定时间间隔发送⼀个探测报⽂，等待响应

具体行为：

​	1.对端正常响应，重置保活时间

​	2.对端程序崩溃，响应⼀个RTS报⽂，将TCP连接重置

​	3.保活报⽂不可达，等待达到保活探测次数后关闭连接

### TCP流量控制的必要性

1.由于通讯双⽅⽹速不同，通讯⽅任意⼀⽅发送过快都会导致对⽅详细处理不过来，所以就需要把数据放到缓冲区中

2.如果缓冲区满了，发送⽅还在疯狂发送，那接收⽅只能把数据包丢弃。因此我们需要控制发送速率

3.我们缓冲区剩余⼤⼩称之为接收窗⼜，⽤变量win表⽰。如果win=0，则发送⽅停⽌发送



## HTTP

### HTTP介绍

HTTP的优点：

​	1.简单，基本报⽂格式为header+body，头部信息也是key-value简单⽂本的形式，易于理解

​	2.灵活性与扩展性，HTTP协议允许开发人员自定义和扩充。HTTP工作在应用层，下层可以随意变化。HTTPS就是在HTTP与TCP之间增加了SSL/TSL安全传输层，HTTP/3把TCP换成了基于UDP的QUIC

HTTP的缺陷：

​	1.无状态，服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担。但它在完成有关联性的操作时会⾮常⿇烦

​	2.明文传输，传输过程中的信息，是可⽅便阅读的，但信息透明，容易被窃取

​	3.不安全，通信使⽤明⽂（不加密），内容可能被窃听；不验证通信⽅的⾝份，因此有可能遭遇伪装；⽆法证明报⽂的完整性，所以有可能已遭篡改

可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致

HTTP：Hyper Text Transfer Protocol：超⽂本传输协议

HTTPS：Hyper Text Transfer Protocol Secure：超⽂本安全传输协议

SSL：Secure Socket Layer 安全套接字

TSL：Transport Layer Security 安全传输层协议

HTTPS = HTTP+SSL/TSL

### HTTPS

HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输

HTTP 的端⼜号是 80，HTTPS 的端⼜号是 443

HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的⾝份是可信的

优点：安全性

​	1.信息加密：交互信息无法被窃取

​	2.校验机制：无法篡改通信内容，篡改后无法正常显示

​	3.身份证书：证明报文的完整

缺点：

​	1.握手阶段延时较高，会话前还需要进行SSL握手

​	2.部署成本高，需要购买CA证书；涉及到加密与解密，占用一定的CPU资源

HPPTS加密方式：对称与非对称的混合加密模式，通信建立前采用非对称加密方式交换会话密钥，通信过程中则使用对称加密对明文内容进行加密

HTTPS的验证流程：

​	1.client发起HTTP请求，连接到server端口

​	2.Server将⾃⼰的信息以数字证书的形式返回给client（证书包含私钥公钥、⽹站地址、证书颁发机构、失效⽇期等）

​	3.Server收到client响应后会先验证证书合法性（地址是否⼀致、是否过期）

​	4.⽣成随机密码（RSA签名）：浏览器会⽣成⼀个随机的对称密钥（session key），并⽤公钥加密，让 server⽤私钥解密，解密后⽤这个对称密钥进⾏传输

​	5.⽣成对称加密算法：验证server⾝份后，client⽣成⼀个对称加密的算法和对应密钥，以公钥加密后发送给server，server使用相同的公钥进行解密。

### 输入网址到网页显示的相关概念

URL：统一资源定位符（网址），格式为“Scheme：//host.domain:port/path/filename”

​	Scheme：定义因特⽹服务类型 http/https/ftp/file

​	Host：定义域主机（http默认主机为www）

​	Domain：因特⽹域名（例如Baidu.com）

​	Port：主机上端口号（http：80，https：443）

​	Path：服务器上的路径（若省略，则⽂档必位于⽹站根⽬录）

​	Filename：⽂档/资源名称

DNS：DNS协议⽤来将域名转换为IP地址，也可将IP地址转换为相应的域名地址

​	  DNS：⾯向⽤户，IP：⾯向主机

​	 域名服务主要是基于UDP实现的，服务器端口号为53

DNS解析过程：

​	浏览器查询URL对应IP：浏览器缓存→操作系统缓存→路由器缓存;

​	三种类型的DNS服务器：根DNS服务器、顶级域DNS服务器、权威DNS服务器;

### HTTP请求

http请求为DNS解析获得IP地址后，通过TCP三次握手，HTTP请求相应消息，关闭TCP连接

HTTP请求报文主要由请求行，请求头和请求体构成

请求行（包括请求方法；URL；协议版本号）——

​	请求方法：GET，POST，PUT，DELETE，PATCH，HEAD，OPTIONS，TRACE

​	URL：<协议>: //<主机>:<端口>//<路径>？<参数>

​	协议版本号：HTTP版本号

请求头——

​	包含请求的附加信息，由key:value组成

请求体——

​	承载多个请求参数的数据。含回车，换行和请求数据（并非都有）

![image-20231224212126440](image-20231224212126440.png)

### HTTP响应报文

响应报文主要由响应行，响应头和响应主体构成

响应行（包括协议版本，状态码，状态码描述）

响应头（类似于请求头），响应体（类似于请求体）

![image-20231224212148625](image-20231224212148625.png)

五类HTTP状态码

![image-20231216110307875](image-20231216110307875.png)

常见状态码描述——200：客户端请求成功

​				206：partial content 服务器已经正确处理部分GET请求，实现断点续传或同时分⽚下载，该请求必须包含Range请 求头来指⽰客户端期望得到的范围

​				301（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使⽤本响应返回的若⼲个URL 之⼀

​				302（临时重定向）：请求的资源现在临时从不同的URI中获得

​				304：如果客户端发送⼀个待条件的GET请求并且该请求以经被允许，⽽⽂档内容未被改变，则返回304,该响应不包含包体（即可直接使⽤缓存）

​				400：请求报⽂语法有误，服务器⽆法识别

​				401：请求需要认证

​				403：请求的对应资源禁⽌被访问

​				404：服务器⽆法找到对应资源

​				500：服务器内部错误 

​				503：服务器正忙

### HTTP请求过程

1.⾸先，我们在浏览器地址栏中，输⼊要查找页⾯的URL，按下Enter

2.浏览器依次在 浏览器缓存 -->>系统缓存 -->>路由器缓存中去寻找匹配的URL，若有，就会直接在屏幕中显⽰出页⾯内容。若没有，则跳到第三步操作

3.发送HTTP请求前，浏览器需要先进⾏域名解析(即DNS解析)，以获取相应的IP地址;（浏览器DNS缓存、路由器 缓存、DNS缓存）

4.获取到IP地址之后，浏览器向服务器发起TCP连接，与浏览器建⽴TCP三次握⼿

5.握⼿成功之后，浏览器就会向服务器发送HTTP请求，来请求服务器端的数据包

6.服务器处理从浏览器端收到的请求，接着将数据返回给浏览器

7.浏览器收到HTTP响应

8.查询状态，状态成功则进⾏下⼀步，不成功则弹出相应指⽰

9.再读取页⾯内容、进⾏浏览器渲染、解析HTML源码;（⽣成DOM树、解析CCS样式、处理JS交互，客户端和服务器交互）进⾏展⽰

10.关闭TCP连接（四次挥⼿）

### HTTP请求方法

 GET：申请获取资源，不对服务器产⽣影响

POST：客户端向服务器提交数据。会影响服务器，服务器可能动态创建新的资源或更新原有资源

HEAD：类似GET，仅要求服务器返回头部信息

PUT：上传某个资源

DELETE：删除某个资源

TRACE：⽤于测试。要求⽬标服务器返回原始的HTTP请求内容

CONNECT：⽤于代理服务器

OPTION：查询服务器对特定URL⽀持的请求⽅法

### GET和POST的区别（特点）

安全与幂等：

​	安全：HTTP协议中，安全是指请求⽅法不会破坏服务器上的资源

​	幂等：多次执⾏相同的操作，结果都相同

GET：

​	1.GET会被浏览器主动缓存的，如果下⼀次传输的数据相同，那么就返回缓存中的内容，以求更快的展⽰数据

​	2.GET的URL⼀般都有长度限制，但需注意HTTP协议中并未规定GET请求的长度。这个长度限制主要是由浏览器 和Web服务器所决定的，并且各个浏览器对长度的限制也各不相同

​	3.GET⽅法只产⽣⼀个TCP数据包，浏览器会把请求头和请求数据⼀并发送出去，服务器响应200 ok（返回数据）

​	4.GET为安全幂等的，因为它为只读操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的

POST：

​	1.POST不安全且不幂等：因为是新增或者提交数据的操作，会修改服务器上的资源；且多次提交数据就会创建多个资源

​	2.POST⽅法的请求信息放置在请求数据中，所以其请求信息没有长度限制	

​	3.POST会产⽣两个TCP数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok（返回数据） 

### HTTP keep-alive机制

使用方法：在请求头中加入Connection : keepalive，通知对端在该请求响应完成后不要关闭，下一次继续用

```
HTTP能不能⼀次连接多次请求，不等后端返回？
可以，HTTP本质是使⽤socket连接，写⼊TCP缓冲是可以连接多次的 
HTTP⽆状态：
在第⼀次和服务器连接并且登录成功之后，第⼆次请求服务器仍然不知道当前请求的是哪个⽤户
```

### cookie和session

cookie：

​	1.在第⼀次登录服务器之后，返回⼀些数据（cookie）给浏览器 

​	2.浏览器将数据保存在本地

​	3.再次发送请求时，⾃动把上⼀次请求存储的cookie发送给服务器

​	4.服务器通过该数据判断⽤户 

​	5.可存储的数据量有限，⼀般不会超过4KB，Cookie的保存形式分为会话Cookie和持久Cookie

```
会话cookie在用户关闭浏览器就会被删除，而持久cookie存在一个指定的过期日期和时间
```

session：session的作⽤与cookie类似，都是为了存储⽤户相关的信息

​	1.cookie存储在本地浏览器的数据，session存储在服务器的数据

​	2.Cookie存储数据的⼤⼩有限制，⽽Session⼀般⽆限制

​	3.Cookie对⽤户信息的⽣命周期的控制⽅式为累计⽅式，⽽Session使⽤间隔⽅式（在用户活跃期间保持信息，而在用户离开或超过一定时间后失效）

​	4.Session的数据存储在服务器更加的安全，但也会占用相应的服务器资源

### SSO（单点登录）

普通登录认证机制在登录认证成功后，服务器把⽤户的登录信息写⼊ session，并为该⽤户⽣成⼀个 cookie，返回 并写⼊浏览器；当⽤户再次访问这个系统的时候，请求中会带上这个 cookie，服务端会根据这个 cookie 找到对应 的 session，通过session来判断这个⽤户是否已经登录

普通的登录认证机制在多系统的环境下，在操作不同的系统时，需要多次登录，会变得很不⽅便

单点登录（英语：Single sign-on，缩写为 SSO），在⼀个多系统的环境中，⽤户只需要登录⼀次，就可以同时登陆访问其他互相信任的系统，以提高效率并减少泄漏风险

## HTTP版本

### HTTP1.1版本新特性

1.默认持久连接：只要客户端任意一端没有明确提出断开TCP连接，就一直保持连接并可以发送多次HTTP请求

2.管线化：客户端可以同时发送多个HTTP请求，不用等待响应

3.端点续传：利用HTTP消息头使用分块传输编码，将实体主体进行分块分割

### HTTP2.0版本新特性

1.传输格式变化：采用二进制格式，不基于文本进行解析

2.多路复用：连接共享，每个连接允许有多个请求，接收方根据请求的ID将请求归属到不同的服务器请求中，提高了效率

3.header压缩：HTTP1.X中，header带有大量信息，而且每次都要重复发送，HTTP2.0通过encoder减少header⼤⼩，通讯双⽅会各⾃缓存⼀份header字段表，既可以避免重复header传输，又减⼩了需要传输的⼤⼩

4.服务端推送：把客户端所需要的资源随着index.html一起发送到客户端，节省了客户端重复请求的步骤。因为没有发起请求，建⽴连接等操作，所以静态资源通过服务器推送，可以极⼤的提升速度。

### HTTP2.0的缺陷

1.队头阻塞：TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在⽹络传输中丢 失了，即使序列号较⾼的 TCP 段已经被接收了，应⽤层也⽆法从内核中读取到这部分数据，从 HTTP 视⻆看，就是请求被阻塞了

2.TCP和TLS的握手时延迟：发出HTTP请求时，需要经过TCP三次握⼿和TLS四次握⼿，共计3RTT的时延才能发出请求数据

3.⽹络迁移需要重新连接：⼀个TCP连接由【源IP地址，源端口，⽬标IP地址，⽬标端口】确定。若IP地址或端⼜发⽣变暖，这需要重新进⾏ 连接。这不利于移动设备切换⽹络的场景。要解决该问题，就要修改传输层协议。在HTTP3中传输层协议修改为了 UDP

### HTTP3.0基于UDP实现的协议——QUIC

HTTP3基于UDP协议在应⽤层 实现了QUIC协议，它有类似TCP的连接管理、拥塞窗口、流量控制的⽹络特性，相当于将不可靠的UDP协议变成可靠的了，⽆需担⼼数据包丢包的问题

QUIC的特点：

​	1.流与流之间不受影响，即便某个流中的数据包丢失，其他流仍然正常工作。即“无队头阻塞”

​	2.更快的连接建立：HTTP/3 在传输数据前虽然需要 QUIC 协议握⼿，这个握⼿过程只需要 1 RTT，握⼿的⽬的是为确认双⽅的「连接 ID」，连接迁移就是基于连接 ID 实现的。的 QUIC 协议并不是与 TLS 分层，⽽是QUIC 内部包含了 TLS，它在⾃⼰的帧会携带 TLS ⾥的“记 录”，再加上 QUIC 使⽤的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与密钥协商，甚⾄在第⼆次 连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果

​	3.连接迁移：QUIC不使用四元组的方式绑定连接，而是通过连接ID标记通信的两个端点，因此即便IP地址变化，只要仍保有上下文信息，就可以无缝复用原连接，减少重连的成本



## IP基础

IP位于TCP/IP参考模型的第三层，也就是⽹络层。网络层实现了主机与主机之间的通信，也叫点对点通信

数据链路层（MAC）负责直连的两个设备之间通信，网络层（IP）负责在没有直连的两个网络之间进行通信传输

在⽹络数据包传输中，源IP地址和⽬标IP地址在传输过程中是不会变的，只有源MAC地址和⽬标MAC⼀直在变化

IPv4，32位，IPv6,128位

如果每一个IP都标识一台电脑，那么可连接的计算机数大概是43亿台。但可以使用NAT技术（更换IP地址的技术），超过这个数字

IP一共五类，根据开头的字段可以很容易分辨，从A到E类分别是0,10,110,1110,1111，其中D类为IP多播地址，E还在保留中

除了IP分类之外，还有CIDR无分类地址，这种⽅式不再有分类地址的概念，32 ⽐特的 IP 地址被划分为两部分，前⾯是⽹络号，后⾯是主机号

表⽰形式 a.b.c.d/x ，其中 /x 表⽰前 x 位属于⽹络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性

![image-20231217162724880](image-20231217162724880.png)

还有另⼀种划分⽹络号与主机号形式，那就是⼦⽹掩码，掩码的意思就是掩盖掉主机号，剩余的就是⽹络号，将⼦⽹掩码和 IP 地址按位计算 AND，就可得到⽹络号，这又进一步增大了网络号的范围

![image-20231217162826455](image-20231217162826455.png)

为什么要分离网络号和主机：

​	因为两台计算机要通讯，⾸先要判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接受⽅在本⽹络上，那么可以把数据包直接发送到⽬标主机

​	路由器寻址⼯作中，也就是通过这样的⽅式来找到对应的⽹络号的，进⽽把数据包转发给对应的⽹络内

​	同时，将网络号和主机号划分的子网掩码同时还可以划分子网

公有/私有IP：

​	公有 IP 地址是有个组织统⼀分配，而私有IP地址允许管理员自己分配和管理，同时可以重复

IP地址和路由控制：

​	IP地址的⽹络地址这⼀部分是⽤于进⾏路由控制。路由控制表中记录着⽹络地址与下⼀步应该发送⾄路由器的地址。在主机和路由器上都会有各⾃的路由器控制表。在发送 IP 包时，⾸先要确定 IP 包⾸部中的⽬标地址，再从路由控制表中找到与该地址具有相同⽹络地址的记录， 根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同⽹络地址的记录，就选择相同位数最多的⽹络地址，也就是最⻓匹配（这里的最长是指IP网络号最长，它取决于网络的掩码长度）

​	IP地址中，环回地址（用于一台计算机的程序之间的网络通信）和localhost都不会流向网络并转发

IP分组与重组：

每种数据链路的最⼤传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太⽹的 MTU 是 1500 字节等

其中，我们最常⻅数据链路是以太⽹，它的 MTU 是 1500 字节。 那么当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被分⽚。 中间的路由器在需要的情况下，对这些片段进行分组和重组。

在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废。所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚而不由 IP 层分⽚；对于 UDP，我们尽量不要发送⼀个⼤于 MTU 的数据报⽂

IPv6：

​	1.IPV4和IPV6不能兼容，它具有更多的地址，更好的安全性和扩展性

​	2.IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址

​	3.IPv6 包头包⾸部⻓度采⽤固定的值 40 字节（IPv4为20字节），去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤提⾼了传输的性能

​	4.IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤提升了安全性

​	5.IPv6 地址⻓度是 128 位，是以每 16 位作为⼀组，每组⽤冒号 「:」 隔开

![image-20231217172001157](image-20231217172001157.png)

相较于IPv4，IPv6的首部改进：

​	1.取消了⾸部校验和字段，因为数据链路层和传输层都会校验

​	2.取消了分⽚/重新组装相关字段：IPv6 不允许在中间路由器进⾏分⽚与重组，这 种操作只能在源与⽬标主机，这将⼤⼤提⾼了路由器转发的速度

​	3.取消选项字段：可能出现在 IPv6 ⾸部中的 「下⼀个⾸部」指出的 位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字节



## DNS基础

DNS（Domain Name Server）域名解析：

我们在上⽹的时候，通常使⽤的⽅式是域名，⽽不是 IP 地址，因为域名⽅便⼈类记忆。那么实现这⼀技术的就是 DNS 域名解析，DNS 可以将域名⽹址⾃动转换为具体的 IP 地址

DNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限。 在域名中，越靠右的位置表⽰其层级越⾼

### ARP与RARP协议（地址解析协议）

（1）ARP协议

在传输⼀个 IP 数据报的时候，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀ 跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址

由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议（Address Resolution Protocol，地址解析协议），求得下⼀跳的 MAC 地址

ARP是如何知道对⽅的MAC地址的呢？ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的

主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址，当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地址与 ⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机

（2）RARP协议

通常这需要架设⼀台 RARP 服务器，在这个 服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络

### DHCP（动态主机配置协议）

DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)。我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程

具体过程为：

​	1.客户端发起DHCP发现报文（广播通信）

​	2.DHCP服务器收到DHCP发现报文时，用DHCP提供报文向客户端做出响应

​	3.客户端收到一个或多个服务器提供的DHCP提供报文后，从中选择一个服务器，并发送DHCP请求报文响应，回显配置的参数

​	4.最后，服务器发送DHCP确认报文对DHCP进行响应，应答所要求的参数

DHCP实现了IP地址的统一分配和管理

### NAT（⽹络地址与端口转换 ）

NAT 就是同个公 司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址

普通的 NAT 转换没什么意义。 由于绝⼤多数的⽹络应⽤都是使⽤传输层协议 TCP 或 UDP 来传输数据 的。 因此，可以把 IP 地址 + 端口号⼀起进⾏转换。 这样，就⽤⼀个公共 IP 地址即可，这种转换技术就叫⽹络地址与端口转换 NAPT

NAT 穿越技术能够让⽹络应⽤程序主动发现⾃⼰位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为 ⾃⼰建⽴端口映射条⽬，注意这些都是 NAT设备后的应⽤程序⾃动完成的。 也就是说，客户端主动从 NAT 设备获 取公有 IP 地址，然后⾃⼰建⽴端⼜映射条⽬，然后⽤这个条⽬对外通信， 就不需要 NAT 设备来进⾏转换了

### ICMP（互联网控制报文协议）

确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等。 在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知。ICMP 的这种通知消息会使⽤IP进⾏发送。

ICMP大致分成两类，一类为诊断的查询信息，一类是通知出错原因的错误消息

![image-20231217184714849](image-20231217184714849.png)

### IGMP（因特网组管理协议）

IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除⾮主机通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了















