# C++新特性

## C++新特性

### C++ 11有哪些新特性

* nullptr替代 NULL
* 引入了 auto 和 decltype 这两个关键字实现了类型推导
* 基于范围的 for 循环for(auto& i : res){}
* 类和结构体的中初始化列表
* Lambda 表达式（匿名函数）
* std::forward\_list（单向链表）
* 右值引用和move语义等

### 智能指针

#### 1.shared\_ptr

shared\_ptr的实现机制是在拷贝构造时使⽤同⼀份引⽤计数

shared\_ptr模版类包含内容：

​ 1.一个模版指针T\* ptr

​ 2.一个引用计数：在底层实现中，这个引用计数器保存在某个内部类型里（这个类型中还包含了deleter，它控制了指针的释放策略，默认情况下就是普通的delete操作），而这个内部类型对象在shared\_ptr第一次构造时以指针的形式保存在shared\_ptr中。

​ 3.重载operator\*和operator->：使得能像指针⼀样使⽤shared\_ptr

​ 4.重载copy constructor（拷贝构造函数）：此时的引用计数加1

​ 5.重载operator=（赋值运算符）：如果原来的shared\_ptr已经有对象，则让其引⽤次数减⼀并判断引⽤是否为零(是否调⽤delete)，然后将新的对象引⽤次数加⼀

​ 6.重载析构函数：使引⽤次数减⼀并判断引⽤是否为零; (是否调⽤delete)

shared\_ptr使用时可能遇到的问题：

​ 1.同时一个shared\_ptr被多个线程”读“是安全的（引用计数管理）

​ 2.同⼀个shared\_ptr被多个线程“写”是不安全的（shared\_ptr仅保证引用计数是原子的，不包括与引用计数相关对象的访问，对于写操作还是得用互斥量等进行额外处理）

​ 3.shared\_ptr失效的唯一情况在循环引用。循环引用指的是，一个引用通过一系列的引用链，最终引用回自身（常常出现在观察者模式中，观察者与目标类之保存着互相的shared\_ptr）。因此它永远无法将内存释放(引用计数始终大于0)，导致内存泄漏。

​ 4.shared\_ptr虽然允许多个无关的shared\_ptr通过赋值操作符实现共享管理，但不允许多个无关shared\_ptr管理同一个裸指针。最好直接用make\_shared接口以实现对象的管理。

​ 5.如果希望一个由shared\_ptr管理的类能够在方法内部得到this指针的shared\_ptr，并且共享管理，则需要继承enable\_shared\_from\_this。

#### 2.weak\_ptr

循环引用的核心在于两个类的内部相互维护着另外一个对象的智能指针，即便将两个类都析构，这个相互（循环）的引用也不会被释放，仍为1。

weak\_ptr是shared\_ptr的"观察者"，它与一个shared\_ptr绑定，但却不参与引用计数的计算，有效避免了循环引用的问题。

同时，在需要的时候，可以随时调用lock方法变为一个shared\_ptr。

在上面提到的观察者模式下，只需要将观察者下的目标对象指针改为weak\_ptr即可（在逻辑上也符合，观察者不应该影响目标对象的资源释放）

#### 3.unique\_ptr

需要将其绑定在一个new返回的指针上，表示同一时刻只有一个unique\_ptr指向给定对象，离开作用域时，如果指向对象，则会将所指对象销毁。

unique不支持拷贝和赋值，不过可以使用release和reset将指针所有权从一个unique\_ptr转移到另一个unique\_ptr。

#### 智能指针注意的点

1. auto\_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；
2. auto\_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto\_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；
3. auto\_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto\_ptr的构造，所以不能直接将一般类型的指针赋值给auto\_ptr类型的对象，必须用auto\_ptr的构造函数创建对象；
4. 由于auto\_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto\_ptr对象管理同一个指针；
5. Auto\_ptr内部实现，析构函数中删除对象用的是delete而不是delete\[]，所以auto\_ptr不能管理数组；
6. auto\_ptr支持所拥有的指针类型之间的隐式类型转换。
7. 可以通过\*和->运算符对auto\_ptr所有用的指针进行提领操作；
8. T\* get(),获得auto\_ptr所拥有的指针；T\* release()，释放auto\_ptr的所有权，并将所有用的指针返回。

### 类型推导

#### 1.auto

auto可以让编译器在编译期就推导出变量的类型

​ 1.auto的使⽤对象必须初始化，否则⽆法推导出类型

​ 2.auto在⼀⾏定义多个变量时，各个变量的推导不能产⽣⼆义性，否则编译失败

​ 3.auto不能⽤作函数参数

​ 4.在类中auto不能⽤作⾮静态成员变量

​ 5.auto不能定义数组，可以定义指针

​ 6.auto⽆法推导出模板参数

​ 7.在不声明为引⽤或指针时，auto会忽略等号右边的引⽤类型和cv限定；相反，在声明为引⽤或者指针时，auto会保留等号右边的引⽤和cv属性

#### 2.decltype

decltype则⽤于推导表达式类型，这⾥只⽤于编译器分析表达式的类型，表达式实际不会进⾏运算

decltype不会像auto⼀样忽略引⽤和cv属性，decltype会保留表达式的引⽤和cv属性

对于decltype(exp)：

​ 1.exp是表达式，decltype(exp)和exp类型相同

​ 2.exp是函数调⽤，decltype(exp)和函数返回值类型相同

​ 3.其他情况，若exp为左值，decltype(exp)为exp类型的左值引用

```c++
template<typename T, typename U>
auto add(T a, U b) -> decltype(a+b){
    return a+b;
}
```

#### 3.decltype(auto)

decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号右边的表达式替换掉auto，再根据decltype的语法规则来确定类型。

```c++
int e = 4;
const int* f = &e; // f是底层const
decltype(auto) j = f;//j的类型是const int* 并且指向的是e
```

### 右值引用

#### 浅拷贝的后果

在两个指针同时指向一块内存的情况下，在经过一次析构后，会导致其中一个指针悬空，悬空指针的内存释放会发生不可预知的结果。

这样的拷贝构造方式被称为浅拷贝，在未声明拷贝构造函数时，系统自动产生，通常最佳的解决方案是自定义拷贝构造函数实现“深拷贝”

#### 左值与右值

左值：可以放等号左边，可以取地址并有名字

右值：不可以放等号左边，不能取地址，没有名字。右值由两个概念构成，一个是将亡值，另一个是纯右值。纯右值是C++98标准中右值的概念，即用于辨识临时变量和不与对象关联的值。

```
++i,--i为左值;i++,i--为右值
```

将亡值：C++11新增的与右值引用相关的表达式，通常是将要被移动的对象。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

左值引用：

​ 1.对左值进行引用的类型，是对象的一个别名，并不拥有所绑定的堆存，所以需要立即初始化。

​ 2.对左值引用而言，等号右边的值必须可以取地址，否则会编译失败。

右值引用：

​ 1.可以使⽤std::move函数强制把左值转换为右值。

#### 移动语义

使用场景：

拷贝构造函数中为指针成员分配新内存再进行内容拷贝的做法不可违背，但有些状况下拷贝构造函数并非必须。在数据量很大的时候，深拷贝所需要的资源非常大。这种情况下，可以在临时对象构造的时候不分配内存，而是直接指向需要的堆内存，这种情况是拷贝构造语义。

移动构造函数接受一个右值引用的参数（临时变量引用），原指针需要置为空避免指针悬挂。函数返回临时变量的好处就在于不需要声明变量，也不需要知道生命周期。

具体：

​ 1.将资源的所有权进行转移，被转移者会失去这块资源的所有权。

​ 2.通过移动构造函数使⽤移动语义，也就是std::move；移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作⽤，还是会拷贝，因为它们实现没有对应的移动构造函数。

额外注意：

​ 1.右值作为临时变量，在一些时候不应被声明为const，声明为const将导致临时变量的引用无法修改。

​ 2.对于移动构造函数而言，抛出异常会出现很大的问题，因为这可能导致指针悬挂。为了尽量不抛出异常，可以添加noexcept关键字，在移动构造函数中抛出的异常会直接调用terminate程序终止运行。

#### 其他

类提供的五种默认函数：

​ 默认构造函数，析构函数，拷贝构造函数，拷贝赋值函数，移动构造函数

​ 拷贝构造函数使用的场景：

​ 1.对象作为构造函数的参数，以值传递的方式传递给函数

​ 2.对象作为函数的返回值，以值的方式从函数返回

​ 3.使用一个对象给另一个对象“初始化”

​ 注意，拷贝构造函数和赋值构造函数的核心区别是，后者将对象的值赋给一个已经存在的实例，而前者是创建一个新的对象实例

```c++
Person p;
Person p1 = p; // p1并没有声明，这里是拷贝构造
Person p2;
p2 = p; // p2已经声明，这里是赋值
```

深拷贝/浅拷贝：

​ 1.浅拷贝——a和b的指针指向了同⼀块内存，就是浅拷贝，只是数据的简单赋值（默认的拷贝构造，拷贝赋值）

​ 2.深拷贝——再拷贝对象时，如果被拷贝对象内部还有指针引⽤指向其它资源，⾃⼰需要重新开辟⼀块新内存存储资源

​ 深拷贝的使用场景：a.动态分配内存

​ b.自定义类的资源管理

​ c.容器类中的元素为指针类型

完美转发：

​ 写⼀个接受任意实参的函数模板，并转发到其它函数，⽬标函数会收到与转发函数完全相同的实参，通过引用折叠实现，具体来说：

```c++
void IamForwarding(T && t){
    IrunCodeActually(static_cast<T &&>(t));
}
```

除非传入一个右值，否则都认为输入的是一个左值

### nullptr

nullptr是⽤来代替NULL，⼀般C++会把NULL、0视为同⼀种东西，这取决去编译器如何定义NULL，有的定义为 ((void\*)0)，有的定义为0

C++不允许直接将void\* 隐式转换到其他类型，在进⾏C++重载时会发⽣混乱，这也导致指针如果定义为NULL时出现需要隐式转换的场合编译器报错

C++11引⼊nullptr关键字来区分空指针和0。nullptr 的类型为 nullptr\_t，能够转换为任何指针或成员指针的类型， 也可以进⾏相等或不等的⽐较

### 范围for循环

```c++
for(auto &i : arr){ // 如果是针对arr的修改，最好加上引号
    ...
}
```

### 列表初始化

C++采用花括号进行初始化，被称为列表初始化

在对于内置类型变量进行初始化时，如果使用列表初始化，且初始值存在信息丢失风险时，编译器会报错

```c++
long double d = 3.1415926536;
int a = {d}; // 信息有丢失风险，转换未执行
```

### lambda表达式

lambda表达式表⽰⼀个可调⽤的代码单元，没有命名的内联函数，不需要函数名因为我们直接（⼀次性的）⽤它， 不需要其他地⽅调⽤

\[捕获列表] (参数列表) -> 返回类型 {函数体 }

其中，只有捕获列表和函数体是必要的。大多是情况下，lambda表达式的返回值可由编译器猜测得出

lambda表达式的捕获列表不同内容时的含义：

​ 1.\[]：不捕获任何变量,这种情况下lambda表达式内部不能访问外部的变量

​ 2.\[&]：以引⽤⽅式捕获所有变量（保证lambda执⾏时变量存在）

​ 3.\[=]：⽤值的⽅式捕获所有变量（创建时拷贝，修改对lambda内对象⽆影响)

​ 4.\[=,\&foo]：以引⽤捕获变量foo, 但其余变量都靠值捕获

​ 5.\[bar]：以值⽅式捕获bar; 不捕获其它变量

​ 6.\[this]：捕获所在类的this指针

当定义了一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。

并发：

#### 1.std::thread

​ std::thread禁止拷贝构造函数

​ 默认构造函数会创建一个空的thread执行对象

​ 初始化构造函数，会创建一个thread对象，该对象可以被joinable，并绑定一个函数执行

​ std::thread还存在一个detach的方法，通过这个方法可以让线程对象和线程函数脱离关系

#### 2.lock\_guard

​ 创建即加锁，作⽤域结束⾃动析构并解锁，⽆需⼿⼯解锁。不能中途解锁，必须等作⽤域结束才解锁。不能复制。

#### 3.unique\_lock

​ uniquelock 是 lockguard 的升级加强版，它具有 lock\_guard 的所有功能，同时又具有其他很多⽅法， 使⽤起来更强灵活⽅便，能够应对更复杂的锁定需要。

特点：

​ 1.创建时可以不锁定（通过指定第⼆个参数为std::defer\_lock），⽽在需要时再锁定

​ 2.可以随时加锁解锁

​ 3.作⽤域规则同 lock\_grard，析构时⾃动释放锁

​ 4.不可复制，可移动

​ 5.条件变量需要该类型的锁作为参数（此时必须使⽤unique\_lock）

## C++11的其他特性

### 变长参数的宏定义

是指在宏定义中参数列表的最后一个参数为省略号，而预定义"\_\_ VA\_ARGS \_\_"则可以在宏定义的实现部分替换省略号代表的字符串，例如：

```c++
#define PR(...) printf(__VA_ARGS__)
```

这样就可以定义printf的别名PR，实际上，变长参数宏和printf往往一起使用，输出不知道具体长度的字符串。

还有一种用法是代替可变参数列表

```c++
#define SYLAR_LOG_FMT_DEBUG(logger, fmt, ...) SYLAR_LOG_FMT_LEVEL(logger, sylar::LogLevel::DEBUG, fmt, __VA_ARGS__)
```

### 断言

在通常情况下，就是将一个返回值总是需要为真的判别式放在语句中，用来排除逻辑不应该发生的情况。

在C++中，标准在< cassert >和\<assert.h>头文件中为提供了assert宏（和直接调用assert函数类似），用于在运行中进行断言。

使用assert的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include \<assert.h>的语句之前插入 #define NDEBUG 来禁用assert调用。还可以使用\ #if 和 #error 实现预处理阶段的断言。

```c++
// 如果 DEBUG_MODE 宏未定义，预处理器将会输出错误消息并中止编译
#if defined(DEBUG_MODE)
#else
    #error "DEBUG_MODE is not defined. Please define it for compilation."
#endif
```

#### 静态断言

assert宏/函数主要用于运行阶段的断言，而 #error 只在编译器预处理时才能起作用（实现断言）。有时候，断言希望出现在编译时（例如模版函数的assert希望被触发，即在编译时触发），这种assert被称为静态断言。在一般的实现上，会使用Boost内置的BOOST\_STATIC\_ASSERT断言机制，但诊断信息不够充分。

在C++11标准中，引入了static\_assert来解决了这个问题。static\_assert使用非常简单，它接受两个参数，一个是断言表达式，这个表达式通常要返回bool值，一个则是警告信息，它通常也就是一段字符串。

```c++
template <typename t, typename u> int bit_copy(t& a, u& b){
    static_assert(sizeof(b) == sizeof(a), "the parameters of bit_copy must have same width.");
}
```

因为是在编译期间的断言，所以使用返回相较于assert更广。但是static\_assert的第一个参数必须是计算期间可以计算的表达式，即必须是常量表达式，如果是变量则会报错

### noexcept修饰符

#### throw和catch

throw 用于在程序执行期间手动引发异常。当程序遇到错误或不可预测的情况时，你可以使用 `throw` 语句来抛出异常对象。这允许程序跳转到适当的异常处理代码。抛出异常的语法为 `throw expression;`，其中 `expression` 是一个可以是任意类型的表达式，通常是异常类的对象。适合在程序的某个点检测到错误或异常情况时，显式地抛出异常，通知上层调用者或异常处理程序。

catch 用于定义异常处理程序，捕获和处理在 try 块中抛出的异常。`catch` 块包含一些代码，它会在匹配特定类型的异常时执行。异常处理的语法为 `catch (exceptionType e) { /* 处理代码 */ }`，其中 `exceptionType` 是期望捕获的异常类型，而 `e` 是一个变量，用于访问异常对象。适合在调用可能抛出异常的代码块时，提供适当的异常处理逻辑。这样可以保证程序在异常发生时能够进行处理而不是崩溃。

#### noexcept

它对应于throw，表示修饰的函数不会抛出异常（告知不会，但不会阻止抛出异常），但如果该函数真的抛出了异常，那么编译器可以选择直接调用std::terminate()函数来终止程序运行，效率上比throw要高，因为不需要额外处理。

noexcept有两种形式，分别是：

```c++
// 1.在函数声明后加上noexcept关键字
void except_func() noexcept;
// 2.接受一个常量表达式作为参数
// 常量表达式的结果会被转化为一个bool类型的值，该值为true表示函数不会抛出异常，反之可能抛出异常
void except_func() noexcept(常量表达式);
```

### 外部模版

#### 外部模版的意义

当不同文件的同一模版实例化的参数相同时，在链接前会生成多个参数相同的模版实例化副本在数据段中，直到链接时再把重复的代码模版删除，保留单个副本，这种工作十分冗余，并且会极大增加编译器的编译和链接时间。解决这个问题的方法和变量共享的思路相同，就是使用“外部的”模本

#### 外部模版的形式

外部模版的声明形式如下：

```c++
extern template void fun<int>(int){}
```

在声明了外部模版后，对应的文件不会再生成`void fun<int>(int)`的实例代码，链接器和编译器的速度得到加快。

### 继承构造函数

派生类只能获得基类的成员变量和虚函数，而非虚函数无法被派生类使用，除非先使用基类的构造函数，并显式的声明。不过可能会出现一种情况，即基类拥有多种构造函数，而派生类为了实现一个接口，需要在自己的构造函数中显式构造不同版本的基类，导致冗余。

这种冗余的解决方案是，如果派生类要使用基类的成员函数，可以通过using声明来实现。同理，对于构造函数而言，也可以使用using声明继承构造函数。

```c++
struct A {
    A(int i) {}
    A(double d, int i){}
}
struct B : A{
    // 基类A的构造函数都被继承到派生类B中
    using A::A;
    virtual void ExtraInterface(){}
}
```

对于使用`using`关键字继承构造函数来说，还有一个关键的意义在于它是隐式声明的，这意味着如果一个继承的构造函数不被代码使用，编译器不会为其产生真正的函数代码，节省了代码空间。

有的时候，基类构造函数的参数会有默认值，这些默认值在使用using时不会继承，同时还要小心重复定义导致的冲突问题。

### 委派构造函数

与继承构造函数类似，委派构造函数的目的也是为了减少多构造函数编写的冗余。

```c++
// 成员初始化的形式
class Info{
public:
    Info() { InitReat(); }
    Info(int i):type(i) { InitReat(); }
    Info(char e):name(e) { InitReadt(); }
private:
    void InitReat() { /其他初始化/ }
    int type = 1;
    char name = 'a';
}

// 委托构造函数的形式
class Info{
public:
    Info() { InitReat(); }
    Info(int i):Info() { type = i; }
    Info(char e):Info() { name = e; }
private:
    void InitReat() { /其他初始化/ }
    int type = 1;
    char name = 'a';
}
```

在初始化列表中调用“基准版本”的构造函数为委派构造函数（`Info(int i)`），而被调用的“基准版本”则为目标构造函数（`Info()`）

不能在初始化列表中既初始化成员，又委托其他构造函数完成构造（`Info()`之后不能初始化成员了）

### 垃圾回收

垃圾回收的方式虽然很多，但主要分成两个大类：

1.基于引用计数的垃圾回收器——

简单来说，引用计数就是使用系统记录对象被引用的次数。当可引用次数变为0时，该对象则被视为垃圾并回收。使用引用计数做垃圾回收的算法优点就是简单，该方法不会造成程序暂停；此外，引用计数也不会对系统的缓存或者交换空间造成冲击，因此“副作用”较小。但是这种方案比较难处理“环形引用”问题，此外由于计数带来的开销，往往会慎重使用。

2.基于跟踪处理的垃圾回收器——

标记-清除算法：这个算法分为两个过程，首先将程序中正在使用的算法视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。在标记结束后，所有被标记的对象就是可达对象（Reachable Object）或者活对象（Live Object），而没有被标记的对象就被认为是垃圾，第二步的清扫阶段就会被回收。

标记-整理算法：在标记完后不再遍历所有对象清扫垃圾，而是将活的对象向左靠齐，这样就解决了内存碎片的问题。标记-整理的方法需要移动活对象，因此对应的程序中所有对堆内存的引用都必须更新。

标记-拷贝算法：这种算法将堆空间分成两个部分：From和To，刚开始系统只从From的堆空间中分配内存，当From分配满后系统开始垃圾回收：从From堆空间中拷贝所有活的对象，拷贝到To的堆空间里。这样，From的堆空间就只剩下垃圾了。同时，在对象拷贝到To里是也是紧凑排列的。最终只需要将From和To交换角色即可。

垃圾回收的兼容性：

C++11标准中对指针的垃圾回收支持仅限于系统提供的new操作符分配的内存，而malloc分配的内存责备认为是可达的，即无论何时垃圾回收器都不予回收。

### tuple作为变长模版展开

C++11中的tuple使用了递归法，使得模版参数包在实例化时能够层层展开，直到参数包中的参数逐渐耗尽或到达某个数量的边界为止。具体如下：

```c++
template <typename ... Elements> class tuple; // 变长模版声明

template<typename Head, typename... Tail> // 递归的偏特化定义
class tuple<Head, Tail...> : private tuple<Tail ...>{
	Head head;  
};

template<> cklass tuple<> {}; // 边界
```

偏特化版本为双参数的tuple版本，该偏特化版本包含了两个参数，一个是类型模版参数Head，另一个是模版参数包Tail。在另一个版本的实现中，将Head型的数据作为tuple\<Head, Tail…>的第一个成员，而将使用包扩展表达式的模版类tuple\<Tail…>作为tuple\<Head,Tail…>的私有基类。这样一来，当需要实例化一个形如tuple\<double, int, char, float>的类型时，则会引起基类的递归构造，这样的递归构造在tuple的参数包为0的时候会结束。即先从tuple<>构造出tuple< float >，继而分别造出tuple\<char, float>，tuple\<int, char, float>，最后建造出tuple\<double, int, char, float>

![image-20240123201141535](../.gitbook/assets/image-20240123201141535.png)
